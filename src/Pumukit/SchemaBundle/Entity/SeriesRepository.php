<?php

namespace Pumukit\SchemaBundle\Entity;

use Doctrine\ORM\EntityRepository;

use Pumukit\SchemaBundle\Entity\MultimediaObject;
use Pumukit\SchemaBundle\Entity\Person;
use Pumukit\SchemaBundle\Entity\Role;
use Pumukit\SchemaBundle\Entity\PersonInMultimediaObject;
use Pumukit\SchemaBundle\Entity\Tag;

/**
 * SeriesRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class SeriesRepository extends EntityRepository
{
	public function findByTag (Tag $tag)
	{
		$em = $this->getEntityManager();
		$query = $em->createQuery('SELECT s 
			FROM PumukitSchemaBundle:Series s
			JOIN s.multimedia_objects mm 
			JOIN mm.tags t 
			WHERE t = :tag
			ORDER BY s.public_date DESC')
		->setParameter('tag', $tag);

		return $query->getResult();
	}

	public function findOneByTag (Tag $tag)
	{
		$em = $this->getEntityManager();
		$query = $em->createQuery('SELECT s 
			FROM PumukitSchemaBundle:Series s
			JOIN s.multimedia_objects mm 
			JOIN mm.tags t 
			WHERE t = :tag
			ORDER BY s.public_date DESC')
		->setParameter('tag', $tag)
		->setMaxResults(1);

		return $query->getSingleResult();
	}

	public function findWithAnyTag(array $tags)
	{
		$em = $this->getEntityManager();
		$query = $em->createQuery('SELECT s 
			FROM PumukitSchemaBundle:Series s
			JOIN s.multimedia_objects mm 
			JOIN mm.tags t 
			WHERE t IN (:tags)
			ORDER BY s.public_date DESC')
		->setParameter('tags', $tags);

		return $query->getResult();
	}

	public function findWithAllTags(array $tags)
	{
		$em = $this->getEntityManager();
		$query = $em->createQuery('SELECT s 
			FROM PumukitSchemaBundle:Series s
			JOIN s.multimedia_objects mm 
			JOIN mm.tags t 
			WHERE t IN (:tags)
			GROUP BY mm
			HAVING COUNT(t) = :numtags
			ORDER BY s.public_date DESC')
		->setParameter('numtags', count($tags))
		->setParameter('tags', $tags);

		return $query->getResult();
	}
	
	public function findOneWithAllTags(array $tags)
	{
		$em = $this->getEntityManager();
		$query = $em->createQuery('SELECT s 
			FROM PumukitSchemaBundle:Series s
			JOIN s.multimedia_objects mm 
			JOIN mm.tags t 
			WHERE t IN (:tags)
			GROUP BY mm
			HAVING COUNT(t) = :numtags
			ORDER BY s.public_date DESC')
		->setParameter('numtags', count($tags))
		->setParameter('tags', $tags)
		->setMaxResults(1);
		return $query->getSingleResult();
	}

	public function findWithoutTag(Tag $tag)
	{

		$em = $this->getEntityManager();
		$query = $em->createQuery('SELECT s 
			FROM PumukitSchemaBundle:Series s
			WHERE s NOT IN(SELECT se
				FROM PumukitSchemaBundle:Series se
				JOIN se.multimedia_objects mm 
				JOIN mm.tags t 
				WHERE t = :tag
				GROUP BY se
				ORDER BY se.public_date DESC)')
		->setParameter('tag', $tag);

		return $query->getResult();
	}

	public function findOneWithoutTag(Tag $tag)
	{
		$em = $this->getEntityManager();
		$query = $em->createQuery('SELECT s 
		FROM PumukitSchemaBundle:Series s
		WHERE s NOT IN(SELECT se
				FROM PumukitSchemaBundle:Series se
				JOIN se.multimedia_objects mm 
				JOIN mm.tags t 
				WHERE t = :tag
				GROUP BY se
				ORDER BY se.public_date DESC)')
		->setParameter('tag', $tag)
		->setMaxResults(1);

		return $query->getSingleResult();
	}

// Note: Maybe a "Find without metatag (category) and children" would be useful
	/**
     * Find series that do not contain SIMULTANEOUSLY all the given tags.
     * Series containing a subset of given tags would be returned.
     *
     * @param Array (Tag) $tags 
     * @return Array
     */
	public function findWithoutAllTags(array $tags)
	{
		$em = $this->getEntityManager();
		$query = $em->createQuery('SELECT se
			FROM PumukitSchemaBundle:Series se
			WHERE se NOT IN(SELECT s 
				FROM PumukitSchemaBundle:Series s
				JOIN s.multimedia_objects mm 
				JOIN mm.tags t 
				WHERE t IN (:tags)
				GROUP BY mm
				HAVING COUNT(t) = :numtags
				ORDER BY s.public_date DESC)')
		->setParameter('numtags', count($tags))
		->setParameter('tags', $tags);

		return $query->getResult();
	}

// TO DO: check if LEFT JOIN will miss mmo without tags (null) 
// If it does not, it would be possible to make a simpler query.
	/**
     * Find series that do not contain any of the given tags.
     * Series containing a subset of given tags would NOT be returned.
     *
     * @param Array (Tag) $tags 
     * @return Array
     */
	public function findWithoutSomeTags(array $tags)
	{
		$em = $this->getEntityManager();
		$query = $em->createQuery('SELECT se
			FROM PumukitSchemaBundle:Series se
			WHERE se NOT IN(SELECT s 
				FROM PumukitSchemaBundle:Series s
				JOIN s.multimedia_objects mm 
				JOIN mm.tags t 
				WHERE t IN (:tags)
				ORDER BY s.public_date DESC)')
		->setParameter('tags', $tags);

		return $query->getResult();
	}
}
// -- hecho testeado public function findByTag (Tag $tag)
// -- hecho testeado public function findOneByTag (Tag $tag)
// -- hecho testeado public function findWithAnyTag(array $tags)
// public function findOneWithAnyTag(array $tags)
// -- hecho testeado public function findWithAllTags(array $tags)
// -- hecho testeado public function findOneWithAllTags(array $tags)
// -- hecho testeado findWithoutTag(array $tags)
// -- hecho testeado public function findOneWithoutTag(array $tags) (not in) 
// -- hecho testeado public function findWithoutSomeTags
